#!/usr/bin/env python3
"""
Phase 2 preprocessing:
* hourly &rarr; daily resample
* advanced features (ret_std_3d, moving averages, RSI‑14)
* create classification target
"""
from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path

import pandas as pd
import ta  # technical‑analysis library

RAW_DIR = Path("data/raw")
PROC_DIR = Path("data/processed")
PROC_DIR.mkdir(parents=True, exist_ok=True)

TODAY = datetime.now(timezone.utc).strftime("%Y-%m-%d")


def ts_log(level: str, msg: str) -> None:
    print(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} [{level}] {msg}")


def load_raw_today() -> pd.DataFrame:
    files = sorted(RAW_DIR.glob(f"*_{TODAY}.json"))
    if not files:
        ts_log("WARN", "No raw data files found for today. Exiting.")
        raise SystemExit(0)

    rows: list[pd.DataFrame] = []
    for f in files:
        coin = f.name.split("_")[0]
        with f.open() as fp:
            raw = json.load(fp)
        df = pd.DataFrame(
            raw, columns=["timestamp_ms", "open", "high", "low", "close"]
        )
        df["coin"] = coin
        rows.append(df)

    return pd.concat(rows, ignore_index=True)


def engineer_features(df: pd.DataFrame) -> pd.DataFrame:
    ts_log("INFO", "Resampling hourly data to daily.")
    df["datetime"] = pd.to_datetime(df["timestamp_ms"], unit="ms", utc=True)
    df = df.set_index("datetime")

    daily = (
        df.groupby("coin")
        .resample("1D")
        .agg({"open": "first", "high": "max", "low": "min", "close": "last"})
        .dropna(subset=["open"])
        .reset_index()
    )
    daily["date"] = daily["datetime"].dt.strftime("%Y-%m-%d")
    daily = daily.drop(columns=["datetime"])

    daily["return_pct"] = ((daily["close"] - daily["open"]) / daily["open"]) * 100
    daily = daily.sort_values(["coin", "date"])

    # Rolling / TA features
    ts_log("INFO", "Calculating advanced features (ret_std_3d, MA, RSI).")

    # 3‑day rolling std of returns
    daily["ret_std_3d"] = (
        daily.groupby("coin")["return_pct"].rolling(window=3).std().reset_index(level=0, drop=True)
    )

    # Moving averages of close
    daily["ma_5d"] = (
        daily.groupby("coin")["close"].rolling(window=5).mean().reset_index(level=0, drop=True)
    )
    daily["ma_10d"] = (
        daily.groupby("coin")["close"].rolling(window=10).mean().reset_index(level=0, drop=True)
    )

    # RSI‑14 on close
    def _rsi(close_series: pd.Series) -> pd.Series:
        return ta.momentum.RSIIndicator(close=close_series, window=14).rsi()

    daily["rsi_14d"] = daily.groupby("coin")["close"].transform(_rsi)

    # Drop any rows with NaNs produced by rolling windows
    n_nan = daily.isna().any(axis=1).sum()
    if n_nan:
        daily = daily.dropna()
        ts_log("INFO", f"Dropped {n_nan} rows with NaN generated by feature engineering.")

    # Target calculation
    daily["next_return"] = daily.groupby("coin")["return_pct"].shift(-1)
    daily["abs_next_return"] = daily["next_return"].abs()
    median_abs = daily.groupby("coin")["abs_next_return"].transform("median")
    daily["target"] = (daily["abs_next_return"] > median_abs).astype("Int64")

    n_target_nan = daily["target"].isna().sum()
    if n_target_nan:
        daily = daily.dropna(subset=["target"])
        ts_log("INFO", f"Dropped {n_target_nan} rows with NaN target.")

    final_cols = [
        "coin",
        "date",
        "return_pct",
        "ret_std_3d",
        "ma_5d",
        "ma_10d",
        "rsi_14d",
        "target",
    ]
    return daily[final_cols].reset_index(drop=True)


def main() -> None:
    ts_log("INFO", f"Starting preprocessing for date {TODAY}...")
    raw_df = load_raw_today()
    ts_log("INFO", f"Loaded data for coins: {sorted(raw_df['coin'].unique())}.")
    processed = engineer_features(raw_df)

    out_file = PROC_DIR / "features.csv"
    processed.to_csv(out_file, index=False)
    ts_log(
        "INFO",
        f"Processed data shape: {processed.shape}. Saved to {out_file.relative_to(Path('.'))}.",
    )


if __name__ == "__main__":
    main()